/* $Id$

(c) Copyright, Real-Time Innovations, 2018.
All rights reserved.

No duplications, whole or partial, manual or electronic, may be made
without express written permission.  Any such copies, or
revisions thereof, must display this notice unaltered.
This code contains trade secrets of Real-Time Innovations, Inc.

============================================================================= */

// This file contains helpers for the interpreted type plugin
// generated by rtiddsgen

#ifndef RTI_DDS_TOPIC_CDR_INTERPRETER_HELPERS_HPP_
#define RTI_DDS_TOPIC_CDR_INTERPRETER_HELPERS_HPP_

// IMPORTANT: macros.hpp must be the first RTI header included in every header
// file so that symbols are exported correctly on Windows
#include <dds/core/macros.hpp>

#include <string>
#include "xcdr/xcdr_typeCode.h"
#include "dds_c/dds_c_typecode.h"

#include "rti/xcdr/Interpreter.hpp"

namespace rti { namespace topic { namespace interpreter {

// This is a macro and not a template function because the function may not be
// inlined by some compilers
#define get_member_value_pointer( \
    T, \
    sample, \
    member_ptr, \
    binding_member_offset, \
    member_info, \
    allocate_member_if_null) \
{ \
    if (member_info != NULL && \
            RTIXCdrTypeCodeMember_isOptional(member_info)) \
    { \
        T **memberPtrPtr = NULL; \
        memberPtrPtr = reinterpret_cast<T **>( \
                ((char *)sample) + binding_member_offset); \
        member_ptr = *memberPtrPtr; \
 \
        if (member_ptr == NULL) { \
            if (allocate_member_if_null) { \
                *memberPtrPtr = \
                        rti::core::memory::ObjectAllocator<T>::create(); \
                member_ptr = *memberPtrPtr; \
            } \
        } \
    } else { \
        member_ptr = reinterpret_cast<T *>( \
                (((char *)sample) + binding_member_offset)); \
    } \
}

// --- Interpreter callbacks: -------------------------------------------------

namespace detail {

template <typename T>
struct length_adjustment {
    enum { value = 0 };
};

// The interpreter includes the '\0' terminator in the length of a string
template <typename CharT>
struct length_adjustment<std::basic_string<CharT> > {
    enum { value = 1 };
};

template <typename SequenceType>
struct sequence_resize {
    static void resize(SequenceType& sequence, size_t size)
    {
        sequence.resize(size);
    }
};

template <typename T, size_t N>
struct sequence_resize<rti::core::bounded_sequence<T, N> > {
    static void resize(rti::core::bounded_sequence<T, N>& seq, size_t size)
    {
        seq.resize_uninitialized(size);
    }
};

template <typename CharT>
struct sequence_resize<std::basic_string<CharT> > {
    static void resize(std::basic_string<CharT>& seq, size_t size)
    {
        seq.resize(size - 1);
    }
};

template <
    typename SequenceType,
    typename ElementType = typename SequenceType::value_type>
struct sequence_helper {
    // The interpreter calls this function to obtain the pointer to the
    // sequence data
    static RTIXCdrMemberValue get_value_pointer(
        void *sample,
        RTIXCdrUnsignedLong *element_count,
        RTIXCdrUnsignedLongLong binding_member_offset,
        RTIXCdrUnsignedLong,
        const struct RTIXCdrTypeCode *,
        const struct RTIXCdrTypeCodeMember *member_info,
        RTIXCdrBoolean,
        void *)
    {
        SequenceType *sequence;
        RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };

        get_member_value_pointer(
            SequenceType,
            sample,
            sequence,
            binding_member_offset,
            member_info,
            // With optional sequences there is no memory allocation
            // in this codepath
            RTI_XCDR_FALSE);

        if (sequence == NULL) {
            return_value.isNull = RTI_XCDR_TRUE;
            return return_value;
        }

        if (element_count != NULL) {
            *element_count = static_cast<RTIXCdrUnsignedLong>(
				sequence->size() + length_adjustment<SequenceType>::value);
        }

        return_value.value.ptr = sequence->empty() ? 
                NULL : 
                (char *) &(*sequence)[0];
        return return_value;
    }

    // The interpreter calls this function to resize a sequence
    static RTIXCdrMemberValue set_element_count(
            RTIXCdrBoolean *error,
            void *sample,
            RTIXCdrUnsignedLong element_count,
            RTIXCdrUnsignedLongLong binding_member_offset,
            const struct RTIXCdrTypeCode *,
            const struct RTIXCdrTypeCodeMember *member_info,
            RTIXCdrBoolean allocate_member_if_null,
            RTIXCdrBoolean,
            void *)
    {
        *error = 0;
        RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };

        try {
            SequenceType *sequence;

            get_member_value_pointer(
                SequenceType,
                sample,
                sequence,
                binding_member_offset,
                member_info,
                allocate_member_if_null);

            if (sequence == NULL) {
                return_value.isNull = RTI_XCDR_TRUE;
                return_value.value.ptr = NULL;
                return return_value;
            }

            sequence_resize<SequenceType>::resize(*sequence, element_count);

            return_value.value.ptr = sequence->empty() ? 
                    NULL :
                    (char *) &(*sequence)[0];
            return return_value;
        } catch (...) {
            *error = 1;
            return return_value;
        }
    }

    static RTIXCdrSampleAccessInfo * sample_access_info()
    {
        static RTIXCdrSampleAccessInfo the_sample_access_info = {
                RTI_XCDR_TYPE_BINDING_CPP_03_STL,
                {sizeof(SequenceType),0,0,0},
                RTI_XCDR_FALSE,
                get_value_pointer,
                set_element_count,
                NULL,
                NULL,
                NULL
        };

        return &the_sample_access_info;
    }

};

// sequences of booleans require a special treatment because std::vector<bool>'s
// specialized implementation doesn't contain a bool*.
template <typename SequenceType>
struct sequence_helper<SequenceType, bool> {

    // The interpreter calls this function to obtain the pointer to the
    // sequence data
    static RTIXCdrMemberValue get_value_pointer(
        void *sample,
        RTIXCdrUnsignedLong *element_count,
        RTIXCdrUnsignedLongLong binding_member_offset,
        RTIXCdrUnsignedLong index,
        const struct RTIXCdrTypeCode *,
        const struct RTIXCdrTypeCodeMember *member_info,
        RTIXCdrBoolean,
        void *)
    {
        SequenceType *sequence;
        RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };

        get_member_value_pointer(
            SequenceType,
            sample,
            sequence,
            binding_member_offset,
            member_info,
            // With optional sequences there is no memory allocation
            // in this codepath
            RTI_XCDR_FALSE);

        if (sequence == NULL) {
            return_value.isNull = RTI_XCDR_TRUE;
            return return_value;
        }

        if (element_count != NULL) {
            *element_count = static_cast<RTIXCdrUnsignedLong>(
				sequence->size() + length_adjustment<SequenceType>::value);
        }

        return_value.value.bVal = sequence->empty() ? 0 : (*sequence)[index];
        return return_value;
    }

    // The interpreter calls this function to resize a sequence
    static RTIXCdrMemberValue set_element_count(
            RTIXCdrBoolean *error,
            void *sample,
            RTIXCdrUnsignedLong element_count,
            RTIXCdrUnsignedLongLong binding_member_offset,
            const struct RTIXCdrTypeCode *,
            const struct RTIXCdrTypeCodeMember *member_info,
            RTIXCdrBoolean allocate_member_if_null,
            RTIXCdrBoolean,
            void *)
    {
        *error = 0;
		RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };
        try {
            SequenceType *sequence;

            get_member_value_pointer(
                SequenceType,
                sample,
                sequence,
                binding_member_offset,
                member_info,
                allocate_member_if_null);

            if (sequence == NULL) {
                return_value.isNull = RTI_XCDR_TRUE;
                return_value.value.ptr = NULL;
                return return_value;
            }

            sequence_resize<SequenceType>::resize(*sequence, element_count);

            return_value.value.bVal = sequence->empty() ? 0 : (*sequence)[0];
            return return_value;
        } catch (...) {
            *error = 1;
            return return_value;
        }
    }

    static void set_element_value(
        void *sample,
        RTIXCdrUnsignedLongLong binding_member_offset,
        RTIXCdrUnsignedLong index,
        RTIXCdrMemberValue value,
        const struct RTIXCdrTypeCode *,
        const struct RTIXCdrTypeCodeMember *member_info,
        RTIXCdrBoolean,
        void *)
    {
        SequenceType *sequence;

        get_member_value_pointer(
            SequenceType,
            sample,
            sequence,
            binding_member_offset,
            member_info,
            // With optional sequences there is no memory allocation
            // in this codepath
            RTI_XCDR_FALSE);

        if (sequence == NULL) {
            return;
        }

        (*sequence)[index] = value.value.bVal ? true : false;
    }

    static RTIXCdrSampleAccessInfo * sample_access_info()
    {
        static RTIXCdrSampleAccessInfo the_sample_access_info = {
                RTI_XCDR_TYPE_BINDING_CPP_03_STL,
                {sizeof(SequenceType),0,0,0},
                RTI_XCDR_FALSE,
                get_value_pointer,
                set_element_count,
                set_element_value,
                NULL,
                NULL
        };

        return &the_sample_access_info;
    }
};

// Use this specialization for sequences of wchar if sizeof(wchar) != 2
// If sizeof(wchar) is 2, this can be treated as any other sequence of
// primitives, and the general template works.
template <typename SequenceType>
struct sequence_helper<
    SequenceType,
    typename rtiboost::enable_if_c<
        rtiboost::is_same<typename SequenceType::value_type, wchar_t>::value
            && sizeof(typename SequenceType::value_type) != 2,
        typename SequenceType::value_type>::type
    > {
    // The interpreter calls this function to obtain the pointer to the
    // sequence data
    static RTIXCdrMemberValue get_value_pointer(
        void *sample,
        RTIXCdrUnsignedLong *element_count,
        RTIXCdrUnsignedLongLong binding_member_offset,
        RTIXCdrUnsignedLong index,
        const struct RTIXCdrTypeCode *,
        const struct RTIXCdrTypeCodeMember *member_info,
        RTIXCdrBoolean,
        void *)
    {
        RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };
        SequenceType *sequence;

        get_member_value_pointer(
            SequenceType,
            sample,
            sequence,
            binding_member_offset,
            member_info,
            // With optional sequences there is no memory allocation
            // in this codepath
            RTI_XCDR_FALSE);

        if (sequence == NULL) {
            return_value.isNull = RTI_XCDR_TRUE;
            return return_value;
        }

        if (element_count != NULL) {
            *element_count = static_cast<RTIXCdrUnsignedLong>(
				sequence->size() + length_adjustment<SequenceType>::value);
        }

        return_value.value.wVal = static_cast<RTIXCdrWchar>(
                sequence->empty() ? 0 : (*sequence)[index]);
        return return_value;
    }

    // The interpreter calls this function to resize a sequence
    static RTIXCdrMemberValue set_element_count(
            RTIXCdrBoolean *error,
            void *sample,
            RTIXCdrUnsignedLong element_count,
            RTIXCdrUnsignedLongLong binding_member_offset,
            const struct RTIXCdrTypeCode *,
            const struct RTIXCdrTypeCodeMember *member_info,
            RTIXCdrBoolean allocate_member_if_null,
            RTIXCdrBoolean,
            void *)
    {
        RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };
        *error = 0;

        try {
            SequenceType *sequence;

            get_member_value_pointer(
                SequenceType,
                sample,
                sequence,
                binding_member_offset,
                member_info,
                allocate_member_if_null);

            if (sequence == NULL) {
                return_value.isNull = RTI_XCDR_TRUE;
                return return_value;
            }

            sequence_resize<SequenceType>::resize(*sequence, element_count);

            return_value.value.wVal = static_cast<RTIXCdrWchar>(
                    sequence->empty() ? 0 : (*sequence)[0]);
            return return_value;
        } catch (...) {
            *error = 1;
            return return_value;
        }
    }

    static void set_element_value(
        void *sample,
        RTIXCdrUnsignedLongLong binding_member_offset,
        RTIXCdrUnsignedLong index,
        RTIXCdrMemberValue value,
        const struct RTIXCdrTypeCode *,
        const struct RTIXCdrTypeCodeMember *member_info,
        RTIXCdrBoolean,
        void *)
    {
        SequenceType *sequence;

        get_member_value_pointer(
            SequenceType,
            sample,
            sequence,
            binding_member_offset,
            member_info,
            // With optional sequences there is no memory allocation
            // in this codepath
            RTI_XCDR_FALSE);

        if (sequence == NULL) {
            return;
        }

        if (index >= sequence->size()) { // ignore null terminator
            return;
        }

        (*sequence)[index] = value.value.wVal;
    }

    static RTIXCdrSampleAccessInfo * sample_access_info()
    {
        static RTIXCdrSampleAccessInfo the_sample_access_info = {
                RTI_XCDR_TYPE_BINDING_CPP_03_STL,
                {sizeof(SequenceType),0,0,0},
                RTI_XCDR_FALSE,
                get_value_pointer,
                set_element_count,
                set_element_value,
                NULL,
                NULL
        };

        return &the_sample_access_info;
    }
};

template <size_t SizeOfWchar>
struct wchar_helper {

    static RTIXCdrMemberValue get_value_pointer(
            void *sample,
            RTIXCdrUnsignedLong *,
            RTIXCdrUnsignedLongLong binding_member_offset,
            RTIXCdrUnsignedLong index,
            const struct RTIXCdrTypeCode *,
            const struct RTIXCdrTypeCodeMember *member_info,
            RTIXCdrBoolean allocate_member_if_null,
            void *)
    {
        RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };

        try {
            wchar_t* field;

            get_member_value_pointer(
                wchar_t,
                sample,
                field,
                binding_member_offset,
                member_info,
                allocate_member_if_null);

            if (field == NULL) {
                return_value.isNull = RTI_XCDR_TRUE;
                return return_value;
            }

            return_value.value.wVal = (RTIXCdrWchar) field[index];
            return return_value;
        } catch (...) {
            return_value.value.wVal = 0;
            return return_value;
        }
    }

    static void set_element_value(
            void *sample,
            RTIXCdrUnsignedLongLong binding_member_offset,
            RTIXCdrUnsignedLong index,
            RTIXCdrMemberValue value,
            const struct RTIXCdrTypeCode *,
            const struct RTIXCdrTypeCodeMember *member_info,
            RTIXCdrBoolean allocate_member_if_null,
            void *)
    {
        try {
            wchar_t* field;

            get_member_value_pointer(
                wchar_t,
                sample,
                field,
                binding_member_offset,
                member_info,
                allocate_member_if_null);

            if (field == NULL) {
                return;
            }

            field[index] = value.value.wVal;
            return;
        } catch (...) {
            return;
        }
    }

    static RTIXCdrSampleAccessInfo * sample_access_info()
    {
        static RTIXCdrSampleAccessInfo the_sample_access_info = {
                RTI_XCDR_TYPE_BINDING_CPP_03_STL,
                {sizeof(wchar_t),0,0,0},
                RTI_XCDR_FALSE,
                get_value_pointer,
                NULL,
                set_element_value,
                NULL,
                NULL
        };

        return &the_sample_access_info;
    }
};

template <>
struct wchar_helper<2> {
    static RTIXCdrSampleAccessInfo * sample_access_info()
    {
        return NULL;
    }
};

template <size_t SizeOfBool>
struct bool_helper {

    static RTIXCdrMemberValue get_value_pointer(
            void *sample,
            RTIXCdrUnsignedLong *,
            RTIXCdrUnsignedLongLong binding_member_offset,
            RTIXCdrUnsignedLong index,
            const struct RTIXCdrTypeCode *,
            const struct RTIXCdrTypeCodeMember *member_info,
            RTIXCdrBoolean allocate_member_if_null,
            void *)
    {
        RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };

        try {
            bool *field;

            get_member_value_pointer(
                bool,
                sample,
                field,
                binding_member_offset,
                member_info,
                allocate_member_if_null);

            if (field == NULL) {
                return_value.isNull = RTI_XCDR_TRUE;
                return return_value;
            }

            return_value.value.bVal = field[index];
            return return_value;
        } catch (...) {
            return_value.value.bVal = RTI_XCDR_FALSE;
            return return_value;
        }
    }

    static void set_element_value(
            void *sample,
            RTIXCdrUnsignedLongLong binding_member_offset,
            RTIXCdrUnsignedLong index,
            RTIXCdrMemberValue value,
            const struct RTIXCdrTypeCode *,
            const struct RTIXCdrTypeCodeMember *member_info,
            RTIXCdrBoolean allocate_member_if_null,
            void *)
    {
        try {
            bool* field;

            get_member_value_pointer(
                bool,
                sample,
                field,
                binding_member_offset,
                member_info,
                allocate_member_if_null);

            if (field == NULL) {
                return;
            }

            field[index] = value.value.bVal;
            return;
        } catch (...) {
            return;
        }
    }

    static RTIXCdrSampleAccessInfo * sample_access_info()
    {
        static RTIXCdrSampleAccessInfo the_sample_access_info = {
                RTI_XCDR_TYPE_BINDING_CPP_03_STL,
                {sizeof(bool),0,0,0},
                RTI_XCDR_FALSE,
                get_value_pointer,
                NULL,
                set_element_value,
                NULL,
                NULL
        };

        return &the_sample_access_info;
    }
};

template <>
struct bool_helper<1> {
    static RTIXCdrSampleAccessInfo * sample_access_info()
    {
        return NULL;
    }
};

} // namespace detail

template <typename AggregationType>
static RTIXCdrMemberValue get_aggregation_value_pointer(
        void *sample,
        RTIXCdrUnsignedLong *,
        RTIXCdrUnsignedLongLong binding_member_offset,
        RTIXCdrUnsignedLong,
        const struct RTIXCdrTypeCode *,
        const struct RTIXCdrTypeCodeMember *member_info,
        RTIXCdrBoolean allocate_member_if_null,
        void *)
{
    RTIXCdrMemberValue return_value = { RTI_XCDR_FALSE, {0} };

    try {
        AggregationType *valuePtr;

        get_member_value_pointer(
            AggregationType,
            sample,
            valuePtr,
            binding_member_offset,
            member_info,
            allocate_member_if_null);

        if (valuePtr == NULL) {
            return_value.isNull = RTI_XCDR_TRUE;
            return return_value;
        }

        return_value.value.ptr = reinterpret_cast<char *>(valuePtr);
        return return_value;
    } catch(...) {
        return_value.value.ptr = NULL;
        return return_value;
    }
}

inline char * get_external_value_pointer(void *ref)
{
    dds::core::external<char> *ref_as_external = 
            reinterpret_cast<dds::core::external<char> *>(ref);
    return ref_as_external->get();
}

template <typename SequenceType>
DDS_TypeCode initialize_sequence_typecode(RTICdrUnsignedLong bound)
{
    static const DDS_TypeCode INITIALIZER = DDS_INITIALIZE_SEQUENCE_TYPECODE(0, NULL);

    DDS_TypeCode type_code = INITIALIZER;

    type_code._data._maximumLength = bound;
    type_code._data._sampleAccessInfo =
            detail::sequence_helper<SequenceType>::sample_access_info();
    return type_code;
}

inline DDS_TypeCode initialize_string_typecode(RTICdrUnsignedLong bound)
{
    static const DDS_TypeCode INITIALIZER = DDS_INITIALIZE_STRING_TYPECODE(0);

    DDS_TypeCode type_code = INITIALIZER;

    type_code._data._maximumLength = bound;
    type_code._data._sampleAccessInfo =
            detail::sequence_helper<std::string>::sample_access_info();
    return type_code;
}

inline DDS_TypeCode initialize_wstring_typecode(RTICdrUnsignedLong bound)
{
    static const DDS_TypeCode INITIALIZER = DDS_INITIALIZE_WSTRING_TYPECODE(0);

    DDS_TypeCode type_code = INITIALIZER;

    type_code._data._maximumLength = bound;
    type_code._data._sampleAccessInfo =
            detail::sequence_helper<std::wstring>::sample_access_info();
    return type_code;
}

inline const DDS_TypeCode& initialize_wchar_typecode()
{
    static DDS_TypeCode type_code = DDS_g_tc_wchar;
    type_code._data._sampleAccessInfo =
            detail::wchar_helper<sizeof(wchar_t)>::sample_access_info();
    return type_code;
}

inline const DDS_TypeCode& initialize_bool_typecode()
{
    static DDS_TypeCode type_code = DDS_g_tc_boolean;
    type_code._data._sampleAccessInfo =
            detail::bool_helper<sizeof(bool)>::sample_access_info();
    return type_code;
}

// Interpreter Programs singleton (for to/from_cdr functions)

namespace detail {

struct PropertyConfigurator {
    static void configure(RTIXCdrInterpreterProgramsGenProperty& property)
    {
        property.externalReferenceSize = 
                (RTIXCdrUnsignedShort) sizeof(dds::core::external<char>);
        property.getExternalRefPointerFcn = 
                rti::topic::interpreter::get_external_value_pointer;
    }
};

}

// Runs the general rti::xcdr::get_cdr_serialization_programs but customizes
// the property via PropertyConfigurator.
template <
    typename TopicType, 
    bool ResolveAlias, 
    bool InlineStruct, 
    bool OptimizeEnum>
RTIXCdrInterpreterPrograms * get_cdr_serialization_programs()
{
    return rti::xcdr::get_cdr_serialization_programs_w_property_configurator<
            TopicType,
            ResolveAlias,
            InlineStruct,
            OptimizeEnum,
            detail::PropertyConfigurator>();
}

} } }

namespace rti { namespace xcdr {

// The xcdr flat data implementation needs type_code to be defined.
// Here, in the modern C++ API we can provide a general implementation.
// In the traditional C++ API type_code is defined for each type in generated
// code.
template <typename TopicType>
struct type_code {
    static const RTIXCdrTypeCode * get()
    {
        return reinterpret_cast<const RTIXCdrTypeCode *>(
                &rti::topic::dynamic_type<TopicType>::get().native());
    }
};

} }

#endif // RTI_DDS_TOPIC_CDR_INTERPRETER_HELPERS_HPP_
