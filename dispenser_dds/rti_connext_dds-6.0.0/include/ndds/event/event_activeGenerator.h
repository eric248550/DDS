/* (c) Copyright 2003-2018, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)event_activeGenerator.h    generated by: makeheader    Thu Feb 28 22:11:40 2019
 *
 *		built from:	activeGenerator.ifc
 */

#ifndef event_activeGenerator_h
#define event_activeGenerator_h



  #ifndef event_dll_h
    #include "event/event_dll.h"
  #endif
  #ifndef event_timer_h
    #include "event/event_timer.h"
  #endif
  #ifndef event_generator_h
    #include "event/event_generator.h"
  #endif
  #ifndef event_activeObject_h
    #include "event/event_activeObject.h"
  #endif
  #ifndef osapi_threadFactory_h
    #include "osapi/osapi_threadFactory.h"
  #endif

#ifdef __cplusplus
    extern "C" {
#endif

struct REDAWorkerFactory;

struct RTIEventActiveGenerator;

struct RTIEventTimer;

typedef enum {
    RTI_EVENT_ACTIVE_GENERATOR_OVERRIDE_RESCHEDULING_POLICY,
    RTI_EVENT_ACTIVE_GENERATOR_NEVER_DELAY_RESCHEDULING_POLICY
} RTIEventActiveGeneratorReschedulingPolicy;

struct RTIEventActiveGeneratorProperty {
    /*e We put the parent as the first member of the struct to "derive" in C
    */
    struct RTIEventGeneratorProperty parent;
    /*e active generator is an active object */
    struct RTIEventActiveObjectProperty active;
    /*e domainId  Used to give a meaningful name to the thread*/
    int domainId;
    /*e Either the App Id or the participant indexUsed to give a meaningful 
    name to the thread*/
    RTI_UINT32 threadAppId;
    /*e Specifies if the previous field is the App Id or the participant index
    Used to give a meaningful name to the thread*/
    RTIBool participantIndexSpecified;

    /*e
     * Specifies how to reschedule an existing event when posting a new event
     * with reuse = true. By default, the new event overrides the time of the existing
     * event (i.e. the old event is removed, and the new event takes its place).
     *
     * With NEVER_DELAY, the new event will be ignored if its scheduled time
     * is after the existing one. If the new event's time is sooner, it will
     * replace the existing event.
     *
     */
    RTIEventActiveGeneratorReschedulingPolicy reschedulingPolicy;
};


#define RTI_EVENT_ACTIVE_GENERATOR_PROPERTY_DEFAULT { \
    RTI_EVENT_GENERATOR_PROPERTY_DEFAULT,   		\
    RTI_EVENT_ACTIVE_OBJECT_PROPERTY_DEFAULT,		\
    0, /* domainId */					      \
    0, /* threadAppId */				      \
    RTI_FALSE, /* participantIndexSpecified */ \
    RTI_EVENT_ACTIVE_GENERATOR_OVERRIDE_RESCHEDULING_POLICY \
}

typedef void (*RTIEventActiveGeneratorListenerOnStartedCallback)(
    struct RTIEventActiveGenerator *generator, void *onStartedParam,
    struct REDAWorker *worker);

struct RTIEventActiveGeneratorListener {
    /*e Parent's state change */
    struct RTIEventActiveObjectListener parent;
    /*e Generator's start-up is asynchronous, so use this method
      to learn when the active generator is fully operational.
    */
    RTIEventActiveGeneratorListenerOnStartedCallback onStarted;
    /*e Associated with the onStarted() method */
    void *onStartedParam;
};

extern RTIEventDllExport void
RTIEventActiveGenerator_delete(struct RTIEventActiveGenerator *me,
                               struct REDAWorker *worker);

extern RTIEventDllExport struct RTIEventActiveGenerator *
RTIEventActiveGenerator_new(
    const char * name,
    struct REDAWorkerFactory *workerFactory,
    struct RTIClock *clock, struct RTIEventTimer *timer,
    const struct RTIEventActiveGeneratorListener *listener,
    const struct RTIEventActiveGeneratorProperty *property,
    struct RTIOsapiThreadFactory *threadFactory,
    struct REDAWorker *worker);

extern RTIEventDllExport RTIBool
RTIEventActiveGenerator_shutdown(struct RTIEventActiveGenerator *me,
				 struct REDAWorker *worker);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* event_activeGenerator_h */
