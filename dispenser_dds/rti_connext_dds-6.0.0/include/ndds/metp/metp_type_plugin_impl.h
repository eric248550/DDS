/* (c) Copyright 2003-2018, Real-Time Innovations, Inc. All rights reserved. */
/*
 * @(#)metp_type_plugin_impl.h    generated by: makeheader    Thu Feb 28 22:13:14 2019
 *
 *		built from:	type_plugin_impl.ifc
 */

#ifndef metp_type_plugin_impl_h
#define metp_type_plugin_impl_h


#ifndef metp_dll_h
#include "metp/metp_dll.h"
#endif

#include "ndds/ndds_c.h"
#include "dds_c/dds_c_infrastructure_impl.h"
#include "metp/metp_type_plugin.h"

#ifdef __cplusplus
extern "C" {
#endif
    



/*i 
 @brief METPMemBufferState_t 
 */
typedef enum {
    METP_MEMBUFFERSTATE_FREE       = 0x0,
    METP_MEMBUFFERSTATE_ALLOCATED  = 0x1,
    METP_MEMBUFFERSTATE_REMOVED    = 0x2,
    METP_MEMBUFFERSTATE_SERIALIZED = 0x3
} METPMemBufferState_t;

/*i 
 @brief METPMemBufferKind_t 
 */
typedef enum  {
    METP_MEMBUFFERKIND_SHMEM   = 0x1,
    METP_MEMBUFFERKIND_HEAP = 0x2
} METPMemBufferKind_t;

/*i 
    @brief METPMemBufferState
    The METPMemBufferState is a sample header. The size of the sample header is
    stored in its last field - size_of_buffer_state.

    METPMemBufferState - BS
    Sample - S
    Padding - P
    | BS1 | S1 | <P> | BS2 | S2 | <P> |...| BSn | Sn |

    The samples are always aligned to 8 Bytes. In order to be able to read the
    size of BufferState by looking at 4 Bytes preceding the sample, we
    need to ensure there is no padding between BufferState and the sample.

    For this purpose, the sizeof(METPMemBufferState) is ensured to be a multiple
    of 8 by adding explicit padding internally (padding_1). The current size of
    METPMemBufferState  is 48 on both 32 and 64 BIT systems.

    In future releases additional fields can be added to the Buffer State. They
    must be added before size_of_buffer_state and total size of the BufferState
    should be multiple of 8 with explicit padding if needed.
 */
struct METPMemBufferState {
    /* This field is only used by the current owner of the buffer */
    void *owner_private_addr;         /* 64BIT - 8 Byte, 8; 32BIT 4Byte, 4 */
#if !defined(RTI_64BIT)
    DDS_Long padding_1;                        /* 4 Byte, 8 */
#endif
    METPMemBufferKind_t kind;                  /* 4 Byte, 12 */
    METPMemBufferState_t state;                /* 4 Byte, 16 */
    METPMemBufferState_t old_state;            /* 4 Byte, 20 */
    struct REDASequenceNumber related_epoch;   /* 8 Byte, 4 Byte aligned, 28 */
    /* SHMEM_REF BEGIN */
    DDS_UnsignedLong key;                      /* 4 Byte, 32*/
    DDS_UnsignedLong index;                    /* 4 Byte, 36*/
    struct RTINtpTime shm_segment_epoch;       /* 8 Byte, 4 Byte aligned 44 */
    /* SHMEM_REF END */

    /* Additional fields to METPMemBufferState can be added here */

    /* End of Additional fields */
    DDS_UnsignedLong size_of_buffer_state;     /* 4 Byte, 48 */
};

extern METPDllExport void
METypePlugin_set_sample_serialized(const void *sample);

    

extern METPDllExport RTIBool
METypePlugin_serialize(
        PRESTypePluginEndpointData endpoint_data,
        const void *sample,
        struct RTICdrStream *stream,
        RTIBool serialize_encapsulation,
        RTIEncapsulationId encapsulation_id,
        RTIBool serialize_sample,
        void *endpoint_plugin_qos);


extern METPDllExport RTIBool
METypePlugin_deserialize(
        PRESTypePluginEndpointData endpoint_data,
        void **sample,
        RTIBool *drop,
        struct RTICdrStream *stream,
        RTIBool deserialize_encapsulation,
        RTIBool deserialize_sample,
        void *endpoint_plugin_qos);

    
#define METypePlugin_validEncapsulationId(encapsulation_id) \
    ((encapsulation_id == DDS_ENCAPSULATION_ID_SHMEM_REF_PLAIN) ? RTI_TRUE : \
        ((encapsulation_id == DDS_ENCAPSULATION_ID_SHMEM_REF_FLAT_DATA) ? RTI_TRUE : RTI_FALSE))

#define METypePlugin_validShmemEncapsulationId(encapsulation_id) \
        METypePlugin_validEncapsulationId(encapsulation_id)

extern METPDllExport RTIBool
METypePlugin_cdrEnabled(PRESTypePluginEndpointData endpoint_data);


extern METPDllExport DDS_DataRepresentationId_t
METypePlugin_getDataRepresentationId(PRESTypePluginEndpointData endpoint_data);


/**ci
 * @brief Register the Metp class with the 
 *        DomainParticipantFactory
 *  
 * This method will add a record to the DomainParticipantFactory 
 * registry. This record allows us to use the METP methods in 
 * lower layers. Currently the only user of this functionality 
 * is the DynamicData TypePlugin when reading zero-copy types. 
 *  
 * Any service/application that wishes to use zero copy types 
 * with DynamicData readers must call this API before the 
 * DynamicData type is registered with a DomainParticipant. 
 * Routing Service calls register so that zero copy types can be 
 * used on the RS inputs. 
 */ 
extern METPDllExport
RTIBool METypePlugin_register(DDS_DomainParticipantFactory *factory);


/**ci
 * @brief Unregister the Metp class with the 
 *        DomainParticipantFactory
 *  
 * This method will remove the record that was asserted during 
 * METypePlugin_register. This method must be called in order to
 * finalize the factory. 
 */ 
extern METPDllExport
void METypePlugin_unregister(DDS_DomainParticipantFactory *factory);


#define METPPluginProperty_g_DwPrefixNoLastPeriod \
        "dds.data_writer.type_support.shmem_ref_transfer_mode_settings"
#define METPPluginProperty_g_DrPrefixNoLastPeriod \
        "dds.data_reader.type_support.shmem_ref_transfer_mode_settings"
#define METPPluginProperty_g_DwPrefix \
        METPPluginProperty_g_DwPrefixNoLastPeriod "."
#define METPPluginProperty_g_DrPrefix \
        METPPluginProperty_g_DrPrefixNoLastPeriod "."

#ifdef __cplusplus
}	/* extern "C" */
#endif


#endif /* metp_type_plugin_impl_h */
